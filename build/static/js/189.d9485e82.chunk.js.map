{"version":3,"file":"static/js/189.d9485e82.chunk.js","mappings":"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","sources":["../node_modules/@ionic/react-router/src/ReactRouter/IonRouteInner.tsx","../node_modules/@ionic/react-router/src/ReactRouter/utils/matchPath.ts","../node_modules/@ionic/react-router/src/ReactRouter/ReactRouterViewStack.tsx","../node_modules/@ionic/react-router/src/ReactRouter/StackManager.tsx","../node_modules/@ionic/react-router/src/ReactRouter/clonePageElement.ts","../node_modules/@ionic/react-router/src/ReactRouter/IonRouter.tsx","../node_modules/@ionic/react-router/src/ReactRouter/IonReactRouter.tsx","../node_modules/@ionic/react-router/src/ReactRouter/IonReactMemoryRouter.tsx","../node_modules/@ionic/react-router/src/ReactRouter/IonReactHashRouter.tsx","../node_modules/tslib/tslib.es6.mjs"],"sourcesContent":["import type { IonRouteProps } from '@ionic/react';\nimport React from 'react';\nimport { Route } from 'react-router';\n\nexport class IonRouteInner extends React.PureComponent<IonRouteProps> {\n  render() {\n    return (\n      <Route\n        path={this.props.path}\n        exact={this.props.exact}\n        render={this.props.render}\n        {\n          /**\n           * `computedMatch` is a private API in react-router v5 that\n           * has been removed in v6.\n           *\n           * This needs to be removed when we support v6.\n           *\n           * TODO: FW-647\n           */\n          ...((this.props as any).computedMatch !== undefined\n            ? {\n                computedMatch: (this.props as any).computedMatch,\n              }\n            : {})\n        }\n      />\n    );\n  }\n}\n","import { matchPath as reactRouterMatchPath } from 'react-router';\n\ninterface MatchPathOptions {\n  /**\n   * The pathname to match against.\n   */\n  pathname: string;\n  /**\n   * The props to match against, they are identical to the matching props `Route` accepts.\n   */\n  componentProps: {\n    path?: string;\n    from?: string;\n    component?: any;\n    exact?: boolean;\n  };\n}\n\n/**\n * @see https://v5.reactrouter.com/web/api/matchPath\n */\nexport const matchPath = ({\n  pathname,\n  componentProps,\n}: MatchPathOptions): false | ReturnType<typeof reactRouterMatchPath> => {\n  const { exact, component } = componentProps;\n\n  const path = componentProps.path || componentProps.from;\n  /***\n   * The props to match against, they are identical\n   * to the matching props `Route` accepts. It could also be a string\n   * or an array of strings as shortcut for `{ path }`.\n   */\n  const matchProps = {\n    exact,\n    path,\n    component,\n  };\n\n  const match = reactRouterMatchPath(pathname, matchProps);\n\n  if (!match) {\n    return false;\n  }\n\n  return match;\n};\n","import type { RouteInfo, ViewItem } from '@ionic/react';\nimport { IonRoute, ViewLifeCycleManager, ViewStacks, generateId } from '@ionic/react';\nimport React from 'react';\n\nimport { matchPath } from './utils/matchPath';\n\nexport class ReactRouterViewStack extends ViewStacks {\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);\n  }\n\n  createViewItem(outletId: string, reactElement: React.ReactElement, routeInfo: RouteInfo, page?: HTMLElement) {\n    const viewItem: ViewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false,\n    };\n\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n\n    viewItem.routeData = {\n      match: matchPath({\n        pathname: routeInfo.pathname,\n        componentProps: reactElement.props,\n      }),\n      childProps: reactElement.props,\n    };\n\n    return viewItem;\n  }\n\n  getChildrenToRender(outletId: string, ionRouterOutlet: React.ReactElement, routeInfo: RouteInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId);\n\n    // Sync latest routes with viewItems\n    React.Children.forEach(ionRouterOutlet.props.children, (child: React.ReactElement) => {\n      const viewItem = viewItems.find((v) => {\n        return matchComponent(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n\n    const children = viewItems.map((viewItem) => {\n      let clonedChild;\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n      } else {\n        const match = matchComponent(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n\n      return clonedChild;\n    });\n    return children;\n  }\n\n  findViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string, updateMatch?: boolean) {\n    const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);\n    const shouldUpdateMatch = updateMatch === undefined || updateMatch === true;\n    if (shouldUpdateMatch && viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n    return viewItem;\n  }\n\n  findLeavingViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string, mustBeIonRoute = true) {\n    const { viewItem } = this.findViewItemByPath(routeInfo.lastPathname!, outletId, mustBeIonRoute);\n    return viewItem;\n  }\n\n  findViewItemByPathname(pathname: string, outletId?: string) {\n    const { viewItem } = this.findViewItemByPath(pathname, outletId);\n    return viewItem;\n  }\n\n  /**\n   * Returns the matching view item and the match result for a given pathname.\n   */\n  private findViewItemByPath(pathname: string, outletId?: string, mustBeIonRoute?: boolean) {\n    let viewItem: ViewItem | undefined;\n    let match: ReturnType<typeof matchPath> | undefined;\n    let viewStack: ViewItem[];\n\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n\n    return { viewItem, match };\n\n    function matchView(v: ViewItem) {\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n\n      match = matchPath({\n        pathname,\n        componentProps: v.routeData.childProps,\n      });\n\n      if (match) {\n        /**\n         * Even though we have a match from react-router, we do not know if the match\n         * is for this specific view item.\n         *\n         * To validate this, we need to check if the path and url match the view item's route data.\n         */\n        const hasParameter = match.path.includes(':');\n        if (!hasParameter || (hasParameter && match.url === v.routeData?.match?.url)) {\n          viewItem = v;\n          return true;\n        }\n      }\n      return false;\n    }\n\n    function matchDefaultRoute(v: ViewItem) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {},\n        };\n        viewItem = v;\n        return true;\n      }\n      return false;\n    }\n  }\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string) {\n  return matchPath({\n    pathname,\n    componentProps: node.props,\n  });\n}\n","import type { RouteInfo, StackContextState, ViewItem } from '@ionic/react';\nimport { RouteManagerContext, StackContext, generateId, getConfig } from '@ionic/react';\nimport React from 'react';\n\nimport { clonePageElement } from './clonePageElement';\nimport { matchPath } from './utils/matchPath';\n\n// TODO(FW-2959): types\n\ninterface StackManagerProps {\n  routeInfo: RouteInfo;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface StackManagerState {}\n\nconst isViewVisible = (el: HTMLElement) =>\n  !el.classList.contains('ion-page-invisible') && !el.classList.contains('ion-page-hidden');\n\nexport class StackManager extends React.PureComponent<StackManagerProps, StackManagerState> {\n  id: string;\n  context!: React.ContextType<typeof RouteManagerContext>;\n  ionRouterOutlet?: React.ReactElement;\n  routerOutletElement: HTMLIonRouterOutletElement | undefined;\n  prevProps?: StackManagerProps;\n  skipTransition: boolean;\n\n  stackContextValue: StackContextState = {\n    registerIonPage: this.registerIonPage.bind(this),\n    isInOutlet: () => true,\n  };\n\n  private clearOutletTimeout: any;\n  private pendingPageTransition = false;\n\n  constructor(props: StackManagerProps) {\n    super(props);\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n    this.prevProps = undefined;\n    this.skipTransition = false;\n  }\n\n  componentDidMount() {\n    if (this.clearOutletTimeout) {\n      /**\n       * The clearOutlet integration with React Router is a bit hacky.\n       * It uses a timeout to clear the outlet after a transition.\n       * In React v18, components are mounted and unmounted in development mode\n       * to check for side effects.\n       *\n       * This clearTimeout prevents the outlet from being cleared when the component is re-mounted,\n       * which should only happen in development mode and as a result of a hot reload.\n       */\n      clearTimeout(this.clearOutletTimeout);\n    }\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement);\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps: StackManagerProps) {\n    const { pathname } = this.props.routeInfo;\n    const { pathname: prevPathname } = prevProps.routeInfo;\n\n    if (pathname !== prevPathname) {\n      this.prevProps = prevProps;\n      this.handlePageTransition(this.props.routeInfo);\n    } else if (this.pendingPageTransition) {\n      this.handlePageTransition(this.props.routeInfo);\n      this.pendingPageTransition = false;\n    }\n  }\n\n  componentWillUnmount() {\n    this.clearOutletTimeout = this.context.clearOutlet(this.id);\n  }\n\n  async handlePageTransition(routeInfo: RouteInfo) {\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      /**\n       * The route outlet has not mounted yet. We need to wait for it to render\n       * before we can transition the page.\n       *\n       * Set a flag to indicate that we should transition the page after\n       * the component has updated.\n       */\n      this.pendingPageTransition = true;\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n        leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);\n      }\n\n      // Check if leavingViewItem should be unmounted\n      if (leavingViewItem) {\n        if (routeInfo.routeAction === 'replace') {\n          leavingViewItem.mount = false;\n        } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n          if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n            leavingViewItem.mount = false;\n          }\n        } else if (routeInfo.routeOptions?.unmount) {\n          leavingViewItem.mount = false;\n        }\n      }\n\n      const enteringRoute = matchRoute(this.ionRouterOutlet?.props.children, routeInfo) as React.ReactElement;\n\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      } else if (enteringRoute) {\n        enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n        this.context.addViewItem(enteringViewItem);\n      }\n\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        /**\n         * If the entering view item is the same as the leaving view item,\n         * then we don't need to transition.\n         */\n        if (enteringViewItem === leavingViewItem) {\n          /**\n           * If the entering view item is the same as the leaving view item,\n           * we are either transitioning using parameterized routes to the same view\n           * or a parent router outlet is re-rendering as a result of React props changing.\n           *\n           * If the route data does not match the current path, the parent router outlet\n           * is attempting to transition and we cancel the operation.\n           */\n          if (enteringViewItem.routeData.match.url !== routeInfo.pathname) {\n            return;\n          }\n        }\n\n        /**\n         * If there isn't a leaving view item, but the route info indicates\n         * that the user has routed from a previous path, then we need\n         * to find the leaving view item to transition between.\n         */\n        if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {\n          leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);\n        }\n\n        /**\n         * If the entering view is already visible and the leaving view is not, the transition does not need to occur.\n         */\n        if (\n          isViewVisible(enteringViewItem.ionPageElement) &&\n          leavingViewItem !== undefined &&\n          !isViewVisible(leavingViewItem.ionPageElement!)\n        ) {\n          return;\n        }\n\n        /**\n         * The view should only be transitioned in the following cases:\n         * 1. Performing a replace or pop action, such as a swipe to go back gesture\n         * to animation the leaving view off the screen.\n         *\n         * 2. Navigating between top-level router outlets, such as /page-1 to /page-2;\n         * or navigating within a nested outlet, such as /tabs/tab-1 to /tabs/tab-2.\n         *\n         * 3. The entering view is an ion-router-outlet containing a page\n         * matching the current route and that hasn't already transitioned in.\n         *\n         * This should only happen when navigating directly to a nested router outlet\n         * route or on an initial page load (i.e. refreshing). In cases when loading\n         * /tabs/tab-1, we need to transition the /tabs page element into the view.\n         */\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        // setTimeout(() => {\n        if (leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n        // }, 250);\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  registerIonPage(page: HTMLElement, routeInfo: RouteInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n    if (foundView) {\n      const oldPageElement = foundView.ionPageElement;\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n\n      /**\n       * React 18 will unmount and remount IonPage\n       * elements in development mode when using createRoot.\n       * This can cause duplicate page transitions to occur.\n       */\n      if (oldPageElement === page) {\n        return;\n      }\n    }\n    this.handlePageTransition(routeInfo);\n  }\n\n  async setupRouterOutlet(routerOutlet: HTMLIonRouterOutletElement) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n      if (!swipeEnabled) {\n        return false;\n      }\n\n      const { routeInfo } = this.props;\n\n      const propsToUse =\n        this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute\n          ? this.prevProps.routeInfo\n          : ({ pathname: routeInfo.pushedByRoute || '' } as any);\n      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n\n      return (\n        !!enteringViewItem &&\n        /**\n         * The root url '/' is treated as\n         * the first view item (but is never mounted),\n         * so we do not want to swipe back to the\n         * root url.\n         */\n        enteringViewItem.mount &&\n        /**\n         * When on the first page (whatever view\n         * you land on after the root url) it\n         * is possible for findViewItemByRouteInfo to\n         * return the exact same view you are currently on.\n         * Make sure that we are not swiping back to the same\n         * instances of a view.\n         */\n        enteringViewItem.routeData.match.path !== routeInfo.pathname\n      );\n    };\n\n    const onStart = async () => {\n      const { routeInfo } = this.props;\n\n      const propsToUse =\n        this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute\n          ? this.prevProps.routeInfo\n          : ({ pathname: routeInfo.pushedByRoute || '' } as any);\n      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n      const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);\n\n      /**\n       * When the gesture starts, kick off\n       * a transition that is controlled\n       * via a swipe gesture.\n       */\n      if (enteringViewItem && leavingViewItem) {\n        await this.transitionPage(routeInfo, enteringViewItem, leavingViewItem, 'back', true);\n      }\n\n      return Promise.resolve();\n    };\n    const onEnd = (shouldContinue: boolean) => {\n      if (shouldContinue) {\n        this.skipTransition = true;\n\n        this.context.goBack();\n      } else {\n        /**\n         * In the event that the swipe\n         * gesture was aborted, we should\n         * re-hide the page that was going to enter.\n         */\n        const { routeInfo } = this.props;\n\n        const propsToUse =\n          this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute\n            ? this.prevProps.routeInfo\n            : ({ pathname: routeInfo.pushedByRoute || '' } as any);\n        const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);\n        const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);\n\n        /**\n         * Ionic React has a design defect where it\n         * a) Unmounts the leaving view item when using parameterized routes\n         * b) Considers the current view to be the entering view when using\n         * parameterized routes\n         *\n         * As a result, we should not hide the view item here\n         * as it will cause the current view to be hidden.\n         */\n        if (enteringViewItem !== leavingViewItem && enteringViewItem?.ionPageElement !== undefined) {\n          const { ionPageElement } = enteringViewItem;\n          ionPageElement.setAttribute('aria-hidden', 'true');\n          ionPageElement.classList.add('ion-page-hidden');\n        }\n      }\n    };\n\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd,\n    };\n  }\n\n  async transitionPage(\n    routeInfo: RouteInfo,\n    enteringViewItem: ViewItem,\n    leavingViewItem?: ViewItem,\n    direction?: 'forward' | 'back',\n    progressAnimation = false\n  ) {\n    const runCommit = async (enteringEl: HTMLElement, leavingEl?: HTMLElement) => {\n      const skipTransition = this.skipTransition;\n\n      /**\n       * If the transition was handled\n       * via the swipe to go back gesture,\n       * then we do not want to perform\n       * another transition.\n       *\n       * We skip adding ion-page or ion-page-invisible\n       * because the entering view already exists in the DOM.\n       * If we added the classes, there would be a flicker where\n       * the view would be briefly hidden.\n       */\n      if (skipTransition) {\n        /**\n         * We need to reset skipTransition before\n         * we call routerOutlet.commit otherwise\n         * the transition triggered by the swipe\n         * to go back gesture would reset it. In\n         * that case you would see a duplicate\n         * transition triggered by handlePageTransition\n         * in componentDidUpdate.\n         */\n        this.skipTransition = false;\n      } else {\n        enteringEl.classList.add('ion-page');\n        enteringEl.classList.add('ion-page-invisible');\n      }\n\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        duration: skipTransition || directionToUse === undefined ? 0 : undefined,\n        direction: directionToUse,\n        showGoBack: !!routeInfo.pushedByRoute,\n        progressAnimation,\n        animationBuilder: routeInfo.routeAnimation,\n      });\n    };\n\n    const routerOutlet = this.routerOutletElement!;\n\n    const routeInfoFallbackDirection =\n      routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root' ? undefined : routeInfo.routeDirection;\n    const directionToUse = direction ?? routeInfoFallbackDirection;\n\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n\n        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem?.ionPageElement);\n        if (leavingViewItem && leavingViewItem.ionPageElement && !progressAnimation) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n  }\n\n  render() {\n    const { children } = this.props;\n    const ionRouterOutlet = React.Children.only(children) as React.ReactElement;\n    this.ionRouterOutlet = ionRouterOutlet;\n\n    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {\n      this.forceUpdate();\n    });\n\n    return (\n      <StackContext.Provider value={this.stackContextValue}>\n        {React.cloneElement(\n          ionRouterOutlet as any,\n          {\n            ref: (node: HTMLIonRouterOutletElement) => {\n              if (ionRouterOutlet.props.setRef) {\n                ionRouterOutlet.props.setRef(node);\n              }\n              if (ionRouterOutlet.props.forwardedRef) {\n                ionRouterOutlet.props.forwardedRef.current = node;\n              }\n              this.routerOutletElement = node;\n              const { ref } = ionRouterOutlet as any;\n              if (typeof ref === 'function') {\n                ref(node);\n              }\n            },\n          },\n          components\n        )}\n      </StackContext.Provider>\n    );\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n}\n\nexport default StackManager;\n\nfunction matchRoute(node: React.ReactNode, routeInfo: RouteInfo) {\n  let matchedNode: React.ReactNode;\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    const match = matchPath({\n      pathname: routeInfo.pathname,\n      componentProps: child.props,\n    });\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  }\n  // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n\n  return matchedNode;\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  return matchPath({\n    pathname,\n    componentProps: {\n      ...node.props,\n      exact: forceExact,\n    },\n  });\n}\n","export function clonePageElement(leavingViewHtml: string | HTMLElement) {\n  let html: string;\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = '';\n    // Remove an existing back button so the new element doesn't get two of them\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n    return newEl.firstChild as HTMLElement;\n  }\n  return undefined;\n}\n","import type {\n  AnimationBuilder,\n  RouteAction,\n  RouteInfo,\n  RouteManagerContextState,\n  RouterDirection,\n  ViewItem,\n} from '@ionic/react';\nimport { LocationHistory, NavManager, RouteManagerContext, generateId, getConfig } from '@ionic/react';\nimport type { Action as HistoryAction, Location as HistoryLocation } from 'history';\nimport React from 'react';\nimport type { RouteComponentProps } from 'react-router-dom';\nimport { withRouter } from 'react-router-dom';\n\nimport { IonRouteInner } from './IonRouteInner';\nimport { ReactRouterViewStack } from './ReactRouterViewStack';\nimport StackManager from './StackManager';\n\nexport interface LocationState {\n  direction?: RouterDirection;\n  routerOptions?: { as?: string; unmount?: boolean };\n}\n\ninterface IonRouteProps extends RouteComponentProps<{}, {}, LocationState> {\n  registerHistoryListener: (cb: (location: HistoryLocation<any>, action: HistoryAction) => void) => void;\n}\n\ninterface IonRouteState {\n  routeInfo: RouteInfo;\n}\n\nclass IonRouterInner extends React.PureComponent<IonRouteProps, IonRouteState> {\n  currentTab?: string;\n  exitViewFromOtherOutletHandlers: ((pathname: string) => ViewItem | undefined)[] = [];\n  incomingRouteParams?: Partial<RouteInfo>;\n  locationHistory = new LocationHistory();\n  viewStack = new ReactRouterViewStack();\n  routeMangerContextState: RouteManagerContextState = {\n    canGoBack: () => this.locationHistory.canGoBack(),\n    clearOutlet: this.viewStack.clear,\n    findViewItemByPathname: this.viewStack.findViewItemByPathname,\n    getChildrenToRender: this.viewStack.getChildrenToRender,\n    goBack: () => this.handleNavigateBack(),\n    createViewItem: this.viewStack.createViewItem,\n    findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n    findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n    addViewItem: this.viewStack.add,\n    unMountViewItem: this.viewStack.remove,\n  };\n\n  constructor(props: IonRouteProps) {\n    super(props);\n\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search,\n    };\n\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNativeBack = this.handleNativeBack.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n\n    this.state = {\n      routeInfo,\n    };\n  }\n\n  handleChangeTab(tab: string, path?: string, routeOptions?: any) {\n    if (!path) {\n      return;\n    }\n\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n    if (routeInfo) {\n      this.incomingRouteParams = { ...routeInfo, routeAction: 'push', routeDirection: 'none' };\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n\n  handleHistoryChange(location: HistoryLocation<LocationState>, action: HistoryAction) {\n    let leavingLocationInfo: RouteInfo;\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab,\n          };\n        }\n        if (action === 'POP') {\n          const currentRoute = this.locationHistory.current();\n          if (currentRoute && currentRoute.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(currentRoute);\n            this.incomingRouteParams = { ...prevInfo, routeAction: 'pop', routeDirection: 'back' };\n          } else {\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: 'none',\n              tab: this.currentTab,\n            };\n          }\n        }\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: location.state?.direction || 'forward',\n            routeOptions: location.state?.routerOptions,\n            tab: this.currentTab,\n          };\n        }\n      }\n\n      let routeInfo: RouteInfo;\n\n      if (this.incomingRouteParams?.id) {\n        routeInfo = {\n          ...(this.incomingRouteParams as RouteInfo),\n          lastPathname: leavingLocationInfo.pathname,\n        };\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed =\n          this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward';\n        routeInfo = {\n          id: generateId('routeInfo'),\n          ...this.incomingRouteParams,\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params,\n          prevRouteLastPathname: leavingLocationInfo.lastPathname,\n        };\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n\n          /**\n           * If going from /home to /child, then replacing from\n           * /child to /home, we don't want the route info to\n           * say that /home was pushed by /home which is not correct.\n           */\n          const currentPushedBy = currentRouteInfo?.pushedByRoute;\n          const pushedByRoute =\n            currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname\n              ? currentPushedBy\n              : routeInfo.pushedByRoute;\n\n          routeInfo.lastPathname = currentRouteInfo?.pathname || routeInfo.lastPathname;\n          routeInfo.prevRouteLastPathname = currentRouteInfo?.lastPathname;\n          routeInfo.pushedByRoute = pushedByRoute;\n\n          /**\n           * When replacing routes we should still prefer\n           * any custom direction/animation that the developer\n           * has specified when navigating first instead of relying\n           * on previously used directions/animations.\n           */\n          routeInfo.routeDirection = routeInfo.routeDirection || currentRouteInfo?.routeDirection;\n          routeInfo.routeAnimation = routeInfo.routeAnimation || currentRouteInfo?.routeAnimation;\n        }\n\n        this.locationHistory.add(routeInfo);\n      }\n\n      this.setState({\n        routeInfo,\n      });\n    }\n\n    this.incomingRouteParams = undefined;\n  }\n\n  /**\n   * history@4.x uses goBack(), history@5.x uses back()\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just\n   * assume back() is available.\n   */\n  handleNativeBack() {\n    const history = this.props.history as any;\n    const goBack = history.goBack || history.back;\n    goBack();\n  }\n\n  handleNavigate(\n    path: string,\n    routeAction: RouteAction,\n    routeDirection?: RouterDirection,\n    routeAnimation?: AnimationBuilder,\n    routeOptions?: any,\n    tab?: string\n  ) {\n    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab,\n    });\n\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n\n  handleNavigateBack(defaultHref: string | RouteInfo = '/', routeAnimation?: AnimationBuilder) {\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref' as any);\n    const routeInfo = this.locationHistory.current();\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n      if (prevInfo) {\n        /**\n         * This needs to be passed to handleNavigate\n         * otherwise incomingRouteParams.routeAnimation\n         * will be overridden.\n         */\n        const incomingAnimation = routeAnimation || routeInfo.routeAnimation;\n        this.incomingRouteParams = {\n          ...prevInfo,\n          routeAction: 'pop',\n          routeDirection: 'back',\n          routeAnimation: incomingAnimation,\n        };\n        if (\n          routeInfo.lastPathname === routeInfo.pushedByRoute ||\n          /**\n           * We need to exclude tab switches/tab\n           * context changes here because tabbed\n           * navigation is not linear, but router.back()\n           * will go back in a linear fashion.\n           */\n          (prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === '' && prevInfo.tab === '')\n        ) {\n          /**\n           * history@4.x uses goBack(), history@5.x uses back()\n           * TODO: If support for React Router <=5 is dropped\n           * this logic is no longer needed. We can just\n           * assume back() is available.\n           */\n          const history = this.props.history as any;\n          const goBack = history.goBack || history.back;\n          goBack();\n        } else {\n          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back', incomingAnimation);\n        }\n      } else {\n        this.handleNavigate(defaultHref as string, 'pop', 'back', routeAnimation);\n      }\n    } else {\n      this.handleNavigate(defaultHref as string, 'pop', 'back', routeAnimation);\n    }\n  }\n\n  handleResetTab(tab: string, originalHref: string, originalRouteOptions: any) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n    if (routeInfo) {\n      const newRouteInfo = { ...routeInfo };\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = { ...newRouteInfo, routeAction: 'pop', routeDirection: 'back' };\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n\n  handleSetCurrentTab(tab: string) {\n    this.currentTab = tab;\n    const ri = { ...this.locationHistory.current() };\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n\n  render() {\n    return (\n      <RouteManagerContext.Provider value={this.routeMangerContextState}>\n        <NavManager\n          ionRoute={IonRouteInner}\n          ionRedirect={{}}\n          stackManager={StackManager}\n          routeInfo={this.state.routeInfo!}\n          onNativeBack={this.handleNativeBack}\n          onNavigateBack={this.handleNavigateBack}\n          onNavigate={this.handleNavigate}\n          onSetCurrentTab={this.handleSetCurrentTab}\n          onChangeTab={this.handleChangeTab}\n          onResetTab={this.handleResetTab}\n          locationHistory={this.locationHistory}\n        >\n          {this.props.children}\n        </NavManager>\n      </RouteManagerContext.Provider>\n    );\n  }\n}\n\nexport const IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n","import type { Action as HistoryAction, History, Location as HistoryLocation } from 'history';\nimport { createBrowserHistory as createHistory } from 'history';\nimport React from 'react';\nimport type { BrowserRouterProps } from 'react-router-dom';\nimport { Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactRouter extends React.Component<IonReactRouterProps> {\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n  history: History;\n\n  constructor(props: IonReactRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import type { Action as HistoryAction, Location as HistoryLocation, MemoryHistory } from 'history';\nimport React from 'react';\nimport type { MemoryRouterProps } from 'react-router';\nimport { Router } from 'react-router';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactMemoryRouterProps extends MemoryRouterProps {\n  history: MemoryHistory;\n}\n\nexport class IonReactMemoryRouter extends React.Component<IonReactMemoryRouterProps> {\n  history: MemoryHistory;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactMemoryRouterProps) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import type { Action as HistoryAction, History, Location as HistoryLocation } from 'history';\nimport { createHashHistory as createHistory } from 'history';\nimport React from 'react';\nimport type { BrowserRouterProps } from 'react-router-dom';\nimport { Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactHashRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactHashRouter extends React.Component<IonReactHashRouterProps> {\n  history: History;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactHashRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n"],"names":["IonRouteInner","React","render","Route","Object","assign","path","this","props","exact","undefined","computedMatch","matchPath","_ref","pathname","componentProps","component","matchProps","from","match","matchPath$1","ReactRouterViewStack","ViewStacks","constructor","super","createViewItem","bind","findViewItemByRouteInfo","findLeavingViewItemByRouteInfo","getChildrenToRender","findViewItemByPathname","outletId","reactElement","routeInfo","page","viewItem","id","generateId","ionPageElement","mount","ionRoute","type","IonRoute","disableIonPageManagement","routeData","childProps","ionRouterOutlet","viewItems","getViewItemsForOutlet","forEach","children","child","find","v","matchComponent$1","map","clonedChild","ViewLifeCycleManager","key","removeView","remove","updateMatch","findViewItemByPath","mustBeIonRoute","arguments","length","lastPathname","viewStack","some","matchView","matchDefaultRoute","getAllViewItems","hasParameter","includes","url","_b","_a","isExact","params","node","isViewVisible","el","classList","contains","StackManager","stackContextValue","registerIonPage","isInOutlet","pendingPageTransition","transitionPage","handlePageTransition","prevProps","skipTransition","componentDidMount","clearOutletTimeout","clearTimeout","routerOutletElement","setupRouterOutlet","componentDidUpdate","prevPathname","componentWillUnmount","context","clearOutlet","commit","enteringViewItem","leavingViewItem","prevRouteLastPathname","routeAction","routeDirection","routeOptions","unmount","enteringRoute","matchedNode","matchRoute","addViewItem","add","setAttribute","forceUpdate","foundView","oldPageElement","routerOutlet","swipeHandler","canStart","config","getConfig","get","mode","propsToUse","pushedByRoute","onStart","async","Promise","resolve","onEnd","shouldContinue","goBack","direction","progressAnimation","runCommit","enteringEl","leavingEl","duration","directionToUse","showGoBack","animationBuilder","routeAnimation","routeInfoFallbackDirection","forceExact","newLeavingElement","leavingViewHtml","html","outerHTML","document","newEl","createElement","innerHTML","style","zIndex","ionBackButton","getElementsByTagName","firstChild","clonePageElement","appendChild","removeChild","only","components","StackContext","Provider","value","ref","setRef","forwardedRef","current","contextType","RouteManagerContext","IonRouterInner","exitViewFromOtherOutletHandlers","locationHistory","LocationHistory","routeMangerContextState","canGoBack","clear","handleNavigateBack","unMountViewItem","location","search","handleChangeTab","handleResetTab","handleNativeBack","handleNavigate","registerHistoryListener","handleHistoryChange","handleSetCurrentTab","state","tab","getCurrentRouteInfoForTab","split","incomingRouteParams","history","push","action","leavingLocationInfo","previous","currentTab","currentRoute","prevInfo","findLastLocation","routerOptions","_c","isPushed","r","lastRoute","currentRouteInfo","currentPushedBy","setState","back","replace","defaultHref","incomingAnimation","originalHref","originalRouteOptions","getFirstRouteInfoForTab","newRouteInfo","ri","update","NavManager","ionRedirect","stackManager","onNativeBack","onNavigateBack","onNavigate","onSetCurrentTab","onChangeTab","onResetTab","IonRouter","withRouter","displayName","IonReactRouter","rest","__rest","createBrowserHistory","listen","locationValue","actionValue","historyListenHandler","cb","Router","IonReactMemoryRouter","Router$1","IonReactHashRouter","createHashHistory","s","e","t","p","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","propertyIsEnumerable","create","SuppressedError"],"sourceRoot":""}